

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tornado.iostream &mdash; Tornado 6.1.dev1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Tornado
          

          
          </a>

          
            
            
              <div class="version">
                6.1.dev1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../guide.html">Userâ€™s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../webframework.html">Web framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../http.html">HTTP servers and clients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking.html">Asynchronous networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../coroutine.html">Coroutines and concurrency</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../integration.html">Integration with other services</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../releases.html">Release notes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Tornado</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>tornado.iostream</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tornado.iostream</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Copyright 2009 Facebook</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="c1"># not use this file except in compliance with the License. You may obtain</span>
<span class="c1"># a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="c1"># WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="c1"># License for the specific language governing permissions and limitations</span>
<span class="c1"># under the License.</span>

<span class="sd">&quot;&quot;&quot;Utility classes to write to and read from non-blocking files and sockets.</span>

<span class="sd">Contents:</span>

<span class="sd">* `BaseIOStream`: Generic interface for reading and writing.</span>
<span class="sd">* `IOStream`: Implementation of BaseIOStream using non-blocking sockets.</span>
<span class="sd">* `SSLIOStream`: SSL-aware version of IOStream.</span>
<span class="sd">* `PipeIOStream`: Pipe-based IOStream implementation.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">ssl</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">from</span> <span class="nn">tornado.concurrent</span> <span class="k">import</span> <span class="n">Future</span><span class="p">,</span> <span class="n">future_set_result_unless_cancelled</span>
<span class="kn">from</span> <span class="nn">tornado</span> <span class="k">import</span> <span class="n">ioloop</span>
<span class="kn">from</span> <span class="nn">tornado.log</span> <span class="k">import</span> <span class="n">gen_log</span>
<span class="kn">from</span> <span class="nn">tornado.netutil</span> <span class="k">import</span> <span class="n">ssl_wrap_socket</span><span class="p">,</span> <span class="n">_client_ssl_defaults</span><span class="p">,</span> <span class="n">_server_ssl_defaults</span>
<span class="kn">from</span> <span class="nn">tornado.util</span> <span class="k">import</span> <span class="n">errno_from_exception</span>

<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Awaitable</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Pattern</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">TracebackType</span>

<span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Deque</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Type</span>  <span class="c1"># noqa: F401</span>

<span class="n">_IOStreamType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_IOStreamType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;IOStream&quot;</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">tornado.platform.posix</span> <span class="k">import</span> <span class="n">_set_nonblocking</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">_set_nonblocking</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>

<span class="c1"># These errnos indicate that a non-blocking operation must be retried</span>
<span class="c1"># at a later time.  On most platforms they&#39;re the same value, but on</span>
<span class="c1"># some they differ.</span>
<span class="n">_ERRNO_WOULDBLOCK</span> <span class="o">=</span> <span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">EWOULDBLOCK</span><span class="p">,</span> <span class="n">errno</span><span class="o">.</span><span class="n">EAGAIN</span><span class="p">)</span>

<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">errno</span><span class="p">,</span> <span class="s2">&quot;WSAEWOULDBLOCK&quot;</span><span class="p">):</span>
    <span class="n">_ERRNO_WOULDBLOCK</span> <span class="o">+=</span> <span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">WSAEWOULDBLOCK</span><span class="p">,)</span>  <span class="c1"># type: ignore</span>

<span class="c1"># These errnos indicate that a connection has been abruptly terminated.</span>
<span class="c1"># They should be caught and handled less noisily than other errors.</span>
<span class="n">_ERRNO_CONNRESET</span> <span class="o">=</span> <span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">ECONNRESET</span><span class="p">,</span> <span class="n">errno</span><span class="o">.</span><span class="n">ECONNABORTED</span><span class="p">,</span> <span class="n">errno</span><span class="o">.</span><span class="n">EPIPE</span><span class="p">,</span> <span class="n">errno</span><span class="o">.</span><span class="n">ETIMEDOUT</span><span class="p">)</span>

<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">errno</span><span class="p">,</span> <span class="s2">&quot;WSAECONNRESET&quot;</span><span class="p">):</span>
    <span class="n">_ERRNO_CONNRESET</span> <span class="o">+=</span> <span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="n">errno</span><span class="o">.</span><span class="n">WSAECONNRESET</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
        <span class="n">errno</span><span class="o">.</span><span class="n">WSAECONNABORTED</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
        <span class="n">errno</span><span class="o">.</span><span class="n">WSAETIMEDOUT</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
    <span class="p">)</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;darwin&quot;</span><span class="p">:</span>
    <span class="c1"># OSX appears to have a race condition that causes send(2) to return</span>
    <span class="c1"># EPROTOTYPE if called while a socket is being torn down:</span>
    <span class="c1"># http://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/</span>
    <span class="c1"># Since the socket is being closed anyway, treat this as an ECONNRESET</span>
    <span class="c1"># instead of an unexpected error.</span>
    <span class="n">_ERRNO_CONNRESET</span> <span class="o">+=</span> <span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">EPROTOTYPE</span><span class="p">,)</span>  <span class="c1"># type: ignore</span>

<span class="c1"># More non-portable errnos:</span>
<span class="n">_ERRNO_INPROGRESS</span> <span class="o">=</span> <span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">EINPROGRESS</span><span class="p">,)</span>

<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">errno</span><span class="p">,</span> <span class="s2">&quot;WSAEINPROGRESS&quot;</span><span class="p">):</span>
    <span class="n">_ERRNO_INPROGRESS</span> <span class="o">+=</span> <span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">WSAEINPROGRESS</span><span class="p">,)</span>  <span class="c1"># type: ignore</span>

<span class="n">_WINDOWS</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;win&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="StreamClosedError"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.StreamClosedError">[docs]</a><span class="k">class</span> <span class="nc">StreamClosedError</span><span class="p">(</span><span class="ne">IOError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exception raised by `IOStream` methods when the stream is closed.</span>

<span class="sd">    Note that the close callback is scheduled to run *after* other</span>
<span class="sd">    callbacks on the stream (to allow for buffered data to be processed),</span>
<span class="sd">    so you may see this error before you see the close callback.</span>

<span class="sd">    The ``real_error`` attribute contains the underlying error that caused</span>
<span class="sd">    the stream to close (if any).</span>

<span class="sd">    .. versionchanged:: 4.3</span>
<span class="sd">       Added the ``real_error`` attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real_error</span><span class="p">:</span> <span class="ne">BaseException</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StreamClosedError</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;Stream is closed&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_error</span> <span class="o">=</span> <span class="n">real_error</span></div>


<div class="viewcode-block" id="UnsatisfiableReadError"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.UnsatisfiableReadError">[docs]</a><span class="k">class</span> <span class="nc">UnsatisfiableReadError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exception raised when a read cannot be satisfied.</span>

<span class="sd">    Raised by ``read_until`` and ``read_until_regex`` with a ``max_bytes``</span>
<span class="sd">    argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="StreamBufferFullError"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.StreamBufferFullError">[docs]</a><span class="k">class</span> <span class="nc">StreamBufferFullError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exception raised by `IOStream` methods when the buffer is full.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<span class="k">class</span> <span class="nc">_StreamBuffer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A specialized buffer that tries to avoid copies when large pieces</span>
<span class="sd">    of data are encountered.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># A sequence of (False, bytearray) and (True, memoryview) objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="p">)</span>  <span class="c1"># type: Deque[Tuple[bool, Union[bytearray, memoryview]]]</span>
        <span class="c1"># Position in the first buffer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>

    <span class="c1"># Data above this size will be appended separately instead</span>
    <span class="c1"># of extending an existing bytearray</span>
    <span class="n">_large_buf_threshold</span> <span class="o">=</span> <span class="mi">2048</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append the given piece of data (should be a buffer-compatible object).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_large_buf_threshold</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="kc">True</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffers</span><span class="p">:</span>
                <span class="n">is_memview</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">new_buf</span> <span class="o">=</span> <span class="n">is_memview</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_large_buf_threshold</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_buf</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">new_buf</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_buffers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="kc">False</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">+=</span> <span class="n">data</span>  <span class="c1"># type: ignore</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">+=</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">memoryview</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a view over at most ``size`` bytes (possibly fewer) at the</span>
<span class="sd">        current buffer position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">is_memview</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_pos</span>
        <span class="k">if</span> <span class="n">is_memview</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">typing</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="nb">memoryview</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">size</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">size</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">advance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advance the current buffer position by ``size`` bytes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">-=</span> <span class="n">size</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_pos</span>

        <span class="n">buffers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffers</span>
        <span class="k">while</span> <span class="n">buffers</span> <span class="ow">and</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">is_large</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">buffers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">b_remain</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">size</span> <span class="o">-</span> <span class="n">pos</span>
            <span class="k">if</span> <span class="n">b_remain</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">buffers</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">size</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">is_large</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="n">size</span>
                <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Amortized O(1) shrink for Python 2</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="n">size</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pos</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">typing</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">,</span> <span class="n">b</span><span class="p">)[:</span><span class="n">pos</span><span class="p">]</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">assert</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_pos</span> <span class="o">=</span> <span class="n">pos</span>


<div class="viewcode-block" id="BaseIOStream"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream">[docs]</a><span class="k">class</span> <span class="nc">BaseIOStream</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A utility class to write to and read from a non-blocking file or socket.</span>

<span class="sd">    We support a non-blocking ``write()`` and a family of ``read_*()``</span>
<span class="sd">    methods. When the operation completes, the ``Awaitable`` will resolve</span>
<span class="sd">    with the data read (or ``None`` for ``write()``). All outstanding</span>
<span class="sd">    ``Awaitables`` will resolve with a `StreamClosedError` when the</span>
<span class="sd">    stream is closed; `.BaseIOStream.set_close_callback` can also be used</span>
<span class="sd">    to be notified of a closed stream.</span>

<span class="sd">    When a stream is closed due to an error, the IOStream&#39;s ``error``</span>
<span class="sd">    attribute contains the exception object.</span>

<span class="sd">    Subclasses must implement `fileno`, `close_fd`, `write_to_fd`,</span>
<span class="sd">    `read_from_fd`, and optionally `get_fd_error`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_buffer_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">read_chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_write_buffer_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;`BaseIOStream` constructor.</span>

<span class="sd">        :arg max_buffer_size: Maximum amount of incoming data to buffer;</span>
<span class="sd">            defaults to 100MB.</span>
<span class="sd">        :arg read_chunk_size: Amount of data to read at one time from the</span>
<span class="sd">            underlying transport; defaults to 64KB.</span>
<span class="sd">        :arg max_write_buffer_size: Amount of outgoing data to buffer;</span>
<span class="sd">            defaults to unlimited.</span>

<span class="sd">        .. versionchanged:: 4.0</span>
<span class="sd">           Add the ``max_write_buffer_size`` parameter.  Changed default</span>
<span class="sd">           ``read_chunk_size`` to 64KB.</span>
<span class="sd">        .. versionchanged:: 5.0</span>
<span class="sd">           The ``io_loop`` argument (deprecated since version 4.1) has been</span>
<span class="sd">           removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span> <span class="o">=</span> <span class="n">ioloop</span><span class="o">.</span><span class="n">IOLoop</span><span class="o">.</span><span class="n">current</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_buffer_size</span> <span class="o">=</span> <span class="n">max_buffer_size</span> <span class="ow">or</span> <span class="mi">104857600</span>
        <span class="c1"># A chunk size that is too close to max_buffer_size can cause</span>
        <span class="c1"># spurious failures.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_chunk_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">read_chunk_size</span> <span class="ow">or</span> <span class="mi">65536</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_buffer_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_write_buffer_size</span> <span class="o">=</span> <span class="n">max_write_buffer_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[BaseException]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_read_buffer</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_after_user_read_buffer</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[bytearray]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_buffer</span> <span class="o">=</span> <span class="n">_StreamBuffer</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_total_write_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_total_write_done_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_delimiter</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[bytes]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_regex</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[Pattern]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_max_bytes</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[int]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_bytes</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[int]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_partial</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_until_close</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_future</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[Future]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_futures</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="p">)</span>  <span class="c1"># type: Deque[Tuple[int, Future[None]]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_callback</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[Callable[[], None]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connect_future</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[Future[IOStream]]</span>
        <span class="c1"># _ssl_connect_future should be defined in SSLIOStream</span>
        <span class="c1"># but it&#39;s here so we can clean it up in _signal_closed</span>
        <span class="c1"># TODO: refactor that so subclasses can add additional futures</span>
        <span class="c1"># to be cancelled.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_connect_future</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[Future[SSLIOStream]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connecting</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[int]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="BaseIOStream.fileno"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.fileno">[docs]</a>    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ioloop</span><span class="o">.</span><span class="n">_Selectable</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns the file descriptor for this stream.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseIOStream.close_fd"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.close_fd">[docs]</a>    <span class="k">def</span> <span class="nf">close_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Closes the file underlying this stream.</span>

<span class="sd">        ``close_fd`` is called by `BaseIOStream` and should not be called</span>
<span class="sd">        elsewhere; other users should call `close` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseIOStream.write_to_fd"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.write_to_fd">[docs]</a>    <span class="k">def</span> <span class="nf">write_to_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">memoryview</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Attempts to write ``data`` to the underlying file.</span>

<span class="sd">        Returns the number of bytes written.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseIOStream.read_from_fd"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.read_from_fd">[docs]</a>    <span class="k">def</span> <span class="nf">read_from_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytearray</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Attempts to read from the underlying file.</span>

<span class="sd">        Reads up to ``len(buf)`` bytes, storing them in the buffer.</span>
<span class="sd">        Returns the number of bytes read. Returns None if there was</span>
<span class="sd">        nothing to read (the socket returned `~errno.EWOULDBLOCK` or</span>
<span class="sd">        equivalent), and zero on EOF.</span>

<span class="sd">        .. versionchanged:: 5.0</span>

<span class="sd">           Interface redesigned to take a buffer and return a number</span>
<span class="sd">           of bytes instead of a freshly-allocated object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseIOStream.get_fd_error"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.get_fd_error">[docs]</a>    <span class="k">def</span> <span class="nf">get_fd_error</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="ne">Exception</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns information about any error on the underlying file.</span>

<span class="sd">        This method is called after the `.IOLoop` has signaled an error on the</span>
<span class="sd">        file descriptor, and should return an Exception (such as `socket.error`</span>
<span class="sd">        with additional information, or None if no such information is</span>
<span class="sd">        available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BaseIOStream.read_until_regex"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.read_until_regex">[docs]</a>    <span class="k">def</span> <span class="nf">read_until_regex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regex</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">max_bytes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Asynchronously read until we have matched the given regex.</span>

<span class="sd">        The result includes the data that matches the regex and anything</span>
<span class="sd">        that came before it.</span>

<span class="sd">        If ``max_bytes`` is not None, the connection will be closed</span>
<span class="sd">        if more than ``max_bytes`` bytes have been read and the regex is</span>
<span class="sd">        not satisfied.</span>

<span class="sd">        .. versionchanged:: 4.0</span>
<span class="sd">            Added the ``max_bytes`` argument.  The ``callback`` argument is</span>
<span class="sd">            now optional and a `.Future` will be returned if it is omitted.</span>

<span class="sd">        .. versionchanged:: 6.0</span>

<span class="sd">           The ``callback`` argument was removed. Use the returned</span>
<span class="sd">           `.Future` instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_read</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_max_bytes</span> <span class="o">=</span> <span class="n">max_bytes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_try_inline_read</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">UnsatisfiableReadError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Handle this the same way as in _handle_events.</span>
            <span class="n">gen_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Unsatisfiable read, closing connection: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">future</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># Ensure that the future doesn&#39;t log an error because its</span>
            <span class="c1"># failure was never examined.</span>
            <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">exception</span><span class="p">())</span>
            <span class="k">raise</span>
        <span class="k">return</span> <span class="n">future</span></div>

<div class="viewcode-block" id="BaseIOStream.read_until"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.read_until">[docs]</a>    <span class="k">def</span> <span class="nf">read_until</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">max_bytes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Asynchronously read until we have found the given delimiter.</span>

<span class="sd">        The result includes all the data read including the delimiter.</span>

<span class="sd">        If ``max_bytes`` is not None, the connection will be closed</span>
<span class="sd">        if more than ``max_bytes`` bytes have been read and the delimiter</span>
<span class="sd">        is not found.</span>

<span class="sd">        .. versionchanged:: 4.0</span>
<span class="sd">            Added the ``max_bytes`` argument.  The ``callback`` argument is</span>
<span class="sd">            now optional and a `.Future` will be returned if it is omitted.</span>

<span class="sd">        .. versionchanged:: 6.0</span>

<span class="sd">           The ``callback`` argument was removed. Use the returned</span>
<span class="sd">           `.Future` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_read</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_delimiter</span> <span class="o">=</span> <span class="n">delimiter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_max_bytes</span> <span class="o">=</span> <span class="n">max_bytes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_try_inline_read</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">UnsatisfiableReadError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Handle this the same way as in _handle_events.</span>
            <span class="n">gen_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Unsatisfiable read, closing connection: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">future</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">exception</span><span class="p">())</span>
            <span class="k">raise</span>
        <span class="k">return</span> <span class="n">future</span></div>

<div class="viewcode-block" id="BaseIOStream.read_bytes"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.read_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">read_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Asynchronously read a number of bytes.</span>

<span class="sd">        If ``partial`` is true, data is returned as soon as we have</span>
<span class="sd">        any bytes to return (but never more than ``num_bytes``)</span>

<span class="sd">        .. versionchanged:: 4.0</span>
<span class="sd">            Added the ``partial`` argument.  The callback argument is now</span>
<span class="sd">            optional and a `.Future` will be returned if it is omitted.</span>

<span class="sd">        .. versionchanged:: 6.0</span>

<span class="sd">           The ``callback`` and ``streaming_callback`` arguments have</span>
<span class="sd">           been removed. Use the returned `.Future` (and</span>
<span class="sd">           ``partial=True`` for ``streaming_callback``) instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_read</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_bytes</span> <span class="o">=</span> <span class="n">num_bytes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_partial</span> <span class="o">=</span> <span class="n">partial</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_try_inline_read</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">exception</span><span class="p">())</span>
            <span class="k">raise</span>
        <span class="k">return</span> <span class="n">future</span></div>

<div class="viewcode-block" id="BaseIOStream.read_into"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.read_into">[docs]</a>    <span class="k">def</span> <span class="nf">read_into</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="nb">bytearray</span><span class="p">,</span> <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Asynchronously read a number of bytes.</span>

<span class="sd">        ``buf`` must be a writable buffer into which data will be read.</span>

<span class="sd">        If ``partial`` is true, the callback is run as soon as any bytes</span>
<span class="sd">        have been read.  Otherwise, it is run when the ``buf`` has been</span>
<span class="sd">        entirely filled with read data.</span>

<span class="sd">        .. versionadded:: 5.0</span>

<span class="sd">        .. versionchanged:: 6.0</span>

<span class="sd">           The ``callback`` argument was removed. Use the returned</span>
<span class="sd">           `.Future` instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_read</span><span class="p">()</span>

        <span class="c1"># First copy data already in read buffer</span>
        <span class="n">available_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">available_bytes</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span> <span class="o">+</span> <span class="n">n</span>
            <span class="n">buf</span><span class="p">[:]</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span> <span class="p">:</span> <span class="n">end</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_after_user_read_buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span>
        <span class="k">elif</span> <span class="n">available_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">buf</span><span class="p">[:</span><span class="n">available_bytes</span><span class="p">]</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span><span class="p">)[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span> <span class="p">:</span>
            <span class="p">]</span>

        <span class="c1"># Set up the supplied buffer as our temporary read buffer.</span>
        <span class="c1"># The original (if it had any data remaining) has been</span>
        <span class="c1"># saved for later.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_read_buffer</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span> <span class="o">=</span> <span class="n">buf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="o">=</span> <span class="n">available_bytes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_bytes</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_partial</span> <span class="o">=</span> <span class="n">partial</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_try_inline_read</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">exception</span><span class="p">())</span>
            <span class="k">raise</span>
        <span class="k">return</span> <span class="n">future</span></div>

<div class="viewcode-block" id="BaseIOStream.read_until_close"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.read_until_close">[docs]</a>    <span class="k">def</span> <span class="nf">read_until_close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Asynchronously reads all data from the socket until it is closed.</span>

<span class="sd">        This will buffer all available data until ``max_buffer_size``</span>
<span class="sd">        is reached. If flow control or cancellation are desired, use a</span>
<span class="sd">        loop with `read_bytes(partial=True) &lt;.read_bytes&gt;` instead.</span>

<span class="sd">        .. versionchanged:: 4.0</span>
<span class="sd">            The callback argument is now optional and a `.Future` will</span>
<span class="sd">            be returned if it is omitted.</span>

<span class="sd">        .. versionchanged:: 6.0</span>

<span class="sd">           The ``callback`` and ``streaming_callback`` arguments have</span>
<span class="sd">           been removed. Use the returned `.Future` (and `read_bytes`</span>
<span class="sd">           with ``partial=True`` for ``streaming_callback``) instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_read</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_finish_read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">future</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_until_close</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_try_inline_read</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">exception</span><span class="p">())</span>
            <span class="k">raise</span>
        <span class="k">return</span> <span class="n">future</span></div>

<div class="viewcode-block" id="BaseIOStream.write"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Future[None]&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Asynchronously write the given data to this stream.</span>

<span class="sd">        This method returns a `.Future` that resolves (with a result</span>
<span class="sd">        of ``None``) when the write has been completed.</span>

<span class="sd">        The ``data`` argument may be of type `bytes` or `memoryview`.</span>

<span class="sd">        .. versionchanged:: 4.0</span>
<span class="sd">            Now returns a `.Future` if no callback is given.</span>

<span class="sd">        .. versionchanged:: 4.5</span>
<span class="sd">            Added support for `memoryview` arguments.</span>

<span class="sd">        .. versionchanged:: 6.0</span>

<span class="sd">           The ``callback`` argument was removed. Use the returned</span>
<span class="sd">           `.Future` instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_closed</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_write_buffer_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buffer</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_write_buffer_size</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="n">StreamBufferFullError</span><span class="p">(</span><span class="s2">&quot;Reached maximum write buffer size&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_total_write_index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>  <span class="c1"># type: Future[None]</span>
        <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">exception</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_futures</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_total_write_index</span><span class="p">,</span> <span class="n">future</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connecting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_write</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_buffer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_io_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">WRITE</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_add_error_listener</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">future</span></div>

<div class="viewcode-block" id="BaseIOStream.set_close_callback"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.set_close_callback">[docs]</a>    <span class="k">def</span> <span class="nf">set_close_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[],</span> <span class="kc">None</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Call the given callback when the stream is closed.</span>

<span class="sd">        This mostly is not necessary for applications that use the</span>
<span class="sd">        `.Future` interface; all outstanding ``Futures`` will resolve</span>
<span class="sd">        with a `StreamClosedError` when the stream is closed. However,</span>
<span class="sd">        it is still useful as a way to signal that the stream has been</span>
<span class="sd">        closed while no other read or write is in progress.</span>

<span class="sd">        Unlike other callback-based interfaces, ``set_close_callback``</span>
<span class="sd">        was not removed in Tornado 6.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_callback</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_add_error_listener</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseIOStream.close"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">exc_info</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="ne">BaseException</span><span class="p">,</span>
            <span class="n">Tuple</span><span class="p">[</span>
                <span class="s2">&quot;Optional[Type[BaseException]]&quot;</span><span class="p">,</span>
                <span class="n">Optional</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">],</span>
                <span class="n">Optional</span><span class="p">[</span><span class="n">TracebackType</span><span class="p">],</span>
            <span class="p">],</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Close this stream.</span>

<span class="sd">        If ``exc_info`` is true, set the ``error`` attribute to the current</span>
<span class="sd">        exception from `sys.exc_info` (or if ``exc_info`` is a tuple,</span>
<span class="sd">        use that instead of `sys.exc_info`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">exc_info</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc_info</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">exc_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc_info</span><span class="p">,</span> <span class="ne">BaseException</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">exc_info</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">exc_info</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">exc_info</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">exc_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_until_close</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_until_close</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_finish_read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">remove_handler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close_fd</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_signal_closed</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_signal_closed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[Future]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_future</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_future</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">futures</span> <span class="o">+=</span> <span class="p">[</span><span class="n">future</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">future</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_futures</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_futures</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connect_future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connect_future</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connect_future</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">future</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
                <span class="n">future</span><span class="o">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">StreamClosedError</span><span class="p">(</span><span class="n">real_error</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">))</span>
            <span class="c1"># Reference the exception to silence warnings. Annoyingly,</span>
            <span class="c1"># this raises if the future was cancelled, but just</span>
            <span class="c1"># returns any other error.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">future</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_connect_future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># _ssl_connect_future expects to see the real exception (typically</span>
            <span class="c1"># an ssl.SSLError), not just StreamClosedError.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_connect_future</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_connect_future</span><span class="o">.</span><span class="n">set_exception</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_connect_future</span><span class="o">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">StreamClosedError</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_connect_future</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_connect_future</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_callback</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_callback</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
        <span class="c1"># Clear the buffers so they can be cleared immediately even</span>
        <span class="c1"># if the IOStream object is kept alive by a reference cycle.</span>
        <span class="c1"># TODO: Clear the read buffer too; it currently breaks some tests.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_buffer</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>

<div class="viewcode-block" id="BaseIOStream.reading"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.reading">[docs]</a>    <span class="k">def</span> <span class="nf">reading</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns ``True`` if we are currently reading from the stream.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BaseIOStream.writing"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.writing">[docs]</a>    <span class="k">def</span> <span class="nf">writing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns ``True`` if we are currently writing to the stream.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buffer</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseIOStream.closed"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.closed">[docs]</a>    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns ``True`` if the stream has been closed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span></div>

<div class="viewcode-block" id="BaseIOStream.set_nodelay"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.BaseIOStream.set_nodelay">[docs]</a>    <span class="k">def</span> <span class="nf">set_nodelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sets the no-delay flag for this stream.</span>

<span class="sd">        By default, data written to TCP streams may be held for a time</span>
<span class="sd">        to make the most efficient use of bandwidth (according to</span>
<span class="sd">        Nagle&#39;s algorithm).  The no-delay flag requests that data be</span>
<span class="sd">        written as soon as possible, even if doing so would consume</span>
<span class="sd">        additional bandwidth.</span>

<span class="sd">        This flag is currently defined only for TCP-based ``IOStreams``.</span>

<span class="sd">        .. versionadded:: 3.1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="k">def</span> <span class="nf">_handle_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_handle_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ioloop</span><span class="o">.</span><span class="n">_Selectable</span><span class="p">],</span> <span class="n">events</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">():</span>
            <span class="n">gen_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Got events for closed stream </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connecting</span><span class="p">:</span>
                <span class="c1"># Most IOLoops will report a write failed connect</span>
                <span class="c1"># with the WRITE event, but SelectIOLoop reports a</span>
                <span class="c1"># READ as well so we must check for connecting before</span>
                <span class="c1"># either.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handle_connect</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">():</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">events</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">READ</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handle_read</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">():</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">events</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">WRITE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handle_write</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">():</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">events</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">ERROR</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fd_error</span><span class="p">()</span>
                <span class="c1"># We may have queued up a user callback in _handle_read or</span>
                <span class="c1"># _handle_write, so don&#39;t close the IOStream until those</span>
                <span class="c1"># callbacks have had a chance to run.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">ERROR</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reading</span><span class="p">():</span>
                <span class="n">state</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">READ</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">writing</span><span class="p">():</span>
                <span class="n">state</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">WRITE</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">ERROR</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If the connection is idle, listen for reads too so</span>
                <span class="c1"># we can tell if the connection is closed.  If there is</span>
                <span class="c1"># data in the read buffer we won&#39;t run the close callback</span>
                <span class="c1"># yet anyway, so we don&#39;t need to listen in this case.</span>
                <span class="n">state</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">READ</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">),</span> <span class="s2">&quot;shouldn&#39;t happen: _handle_events without self._state&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">state</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">update_handler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnsatisfiableReadError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">gen_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Unsatisfiable read, closing connection: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">gen_log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Uncaught exception, closing connection.&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">_read_to_buffer_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># This method is called from _handle_read and _try_inline_read.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_bytes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">target_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_bytes</span>  <span class="c1"># type: Optional[int]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_max_bytes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">target_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_max_bytes</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">reading</span><span class="p">():</span>
            <span class="c1"># For read_until without max_bytes, or</span>
            <span class="c1"># read_until_close, read as much as we can before</span>
            <span class="c1"># scanning for the delimiter.</span>
            <span class="n">target_bytes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_bytes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">next_find_pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">():</span>
            <span class="c1"># Read from the socket until we get EWOULDBLOCK or equivalent.</span>
            <span class="c1"># SSL sockets do some internal buffering, and if the data is</span>
            <span class="c1"># sitting in the SSL object&#39;s buffer select() and friends</span>
            <span class="c1"># can&#39;t see it; the only way to find out if it&#39;s there is to</span>
            <span class="c1"># try to read it.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_to_buffer</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># If we&#39;ve read all the bytes we can use, break out of</span>
            <span class="c1"># this loop.</span>

            <span class="c1"># If we&#39;ve reached target_bytes, we know we&#39;re done.</span>
            <span class="k">if</span> <span class="n">target_bytes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="o">&gt;=</span> <span class="n">target_bytes</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Otherwise, we need to call the more expensive find_read_pos.</span>
            <span class="c1"># It&#39;s inefficient to do this on every read, so instead</span>
            <span class="c1"># do it on the first read and whenever the read buffer</span>
            <span class="c1"># size has doubled.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="o">&gt;=</span> <span class="n">next_find_pos</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_read_pos</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">pos</span>
                <span class="n">next_find_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_read_pos</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_handle_read</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_to_buffer_loop</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">UnsatisfiableReadError</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">gen_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;error on read: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_from_buffer</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_start_read</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Future</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_future</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Already reading&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_future</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_future</span>

    <span class="k">def</span> <span class="nf">_finish_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">streaming</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_read_buffer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_after_user_read_buffer</span> <span class="ow">or</span> <span class="nb">bytearray</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_after_user_read_buffer</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_user_read_buffer</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">size</span>  <span class="c1"># type: Union[int, bytes]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_consume</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_future</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_future</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">future_set_result_unless_cancelled</span><span class="p">(</span><span class="n">future</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_add_error_listener</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_try_inline_read</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Attempt to complete the current read operation from buffered data.</span>

<span class="sd">        If the read can be completed without blocking, schedules the</span>
<span class="sd">        read callback on the next IOLoop iteration; otherwise starts</span>
<span class="sd">        listening for reads on the socket.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># See if we&#39;ve already got the data from a previous read</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_read_pos</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_from_buffer</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_closed</span><span class="p">()</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_to_buffer_loop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_from_buffer</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># We couldn&#39;t satisfy the read inline, so make sure we&#39;re</span>
        <span class="c1"># listening for new data unless the stream is closed.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_io_state</span><span class="p">(</span><span class="n">ioloop</span><span class="o">.</span><span class="n">IOLoop</span><span class="o">.</span><span class="n">READ</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_to_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Reads from the socket and appends the result to the read buffer.</span>

<span class="sd">        Returns the number of bytes read.  Returns 0 if there is nothing</span>
<span class="sd">        to read (i.e. the read returns EWOULDBLOCK or equivalent).  On</span>
<span class="sd">        error closes the socket and raises an exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_read_buffer</span><span class="p">:</span>
                        <span class="n">buf</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span><span class="p">)[</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="p">:</span>
                        <span class="p">]</span>  <span class="c1"># type: Union[memoryview, bytearray]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read_chunk_size</span><span class="p">)</span>
                    <span class="n">bytes_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_from_fd</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">errno_from_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EINTR</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># ssl.SSLError is a subclass of socket.error</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_connreset</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                        <span class="c1"># Treat ECONNRESET as a connection close rather than</span>
                        <span class="c1"># an error to minimize log spam  (the exception will</span>
                        <span class="c1"># be available on self.error for apps that care).</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
                        <span class="k">return</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">raise</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">bytes_read</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">bytes_read</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_read_buffer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span> <span class="o">+=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)[:</span><span class="n">bytes_read</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="o">+=</span> <span class="n">bytes_read</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Break the reference to buf so we don&#39;t waste a chunk&#39;s worth of</span>
            <span class="c1"># memory in case an exception hangs on to our stack frame.</span>
            <span class="k">del</span> <span class="n">buf</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_buffer_size</span><span class="p">:</span>
            <span class="n">gen_log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Reached maximum read buffer size&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">StreamBufferFullError</span><span class="p">(</span><span class="s2">&quot;Reached maximum read buffer size&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bytes_read</span>

    <span class="k">def</span> <span class="nf">_read_from_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Attempts to complete the currently-pending read from the buffer.</span>

<span class="sd">        The argument is either a position in the read buffer or None,</span>
<span class="sd">        as returned by _find_read_pos.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_delimiter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_regex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_partial</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finish_read</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_read_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Attempts to find a position in the read buffer that satisfies</span>
<span class="sd">        the currently-pending read.</span>

<span class="sd">        Returns a position in the buffer if the current read can be satisfied,</span>
<span class="sd">        or None if it cannot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_bytes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_bytes</span>
            <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_partial</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">num_bytes</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_bytes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">num_bytes</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Multi-byte delimiters (e.g. &#39;\r\n&#39;) may straddle two</span>
            <span class="c1"># chunks in the read buffer, so we can&#39;t easily find them</span>
            <span class="c1"># without collapsing the buffer.  However, since protocols</span>
            <span class="c1"># using delimited reads (as opposed to reads of a known</span>
            <span class="c1"># length) tend to be &quot;line&quot; oriented, the delimiter is likely</span>
            <span class="c1"># to be in the first few chunks.  Merge the buffer gradually</span>
            <span class="c1"># since large merges are relatively expensive and get undone in</span>
            <span class="c1"># _consume().</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span><span class="o">.</span><span class="n">find</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_read_delimiter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">loc</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span>
                    <span class="n">delimiter_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_delimiter</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_check_max_bytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_delimiter</span><span class="p">,</span> <span class="n">loc</span> <span class="o">+</span> <span class="n">delimiter_len</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="n">delimiter_len</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_max_bytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_delimiter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_regex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_regex</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">loc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_check_max_bytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_regex</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">loc</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_max_bytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_regex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_check_max_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">],</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_max_bytes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_max_bytes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsatisfiableReadError</span><span class="p">(</span>
                <span class="s2">&quot;delimiter </span><span class="si">%r</span><span class="s2"> not found within </span><span class="si">%d</span><span class="s2"> bytes&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">delimiter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_max_bytes</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_handle_write</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buffer</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">assert</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_WINDOWS</span><span class="p">:</span>
                    <span class="c1"># On windows, socket.send blows up if given a</span>
                    <span class="c1"># write buffer that&#39;s too large, instead of just</span>
                    <span class="c1"># returning the number of bytes it was able to</span>
                    <span class="c1"># process.  Therefore we must not call socket.send</span>
                    <span class="c1"># with more than 128KB at a time.</span>
                    <span class="n">size</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span>

                <span class="n">num_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_to_fd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buffer</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">num_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_buffer</span><span class="o">.</span><span class="n">advance</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_total_write_done_index</span> <span class="o">+=</span> <span class="n">num_bytes</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_ERRNO_WOULDBLOCK</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_connreset</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                        <span class="c1"># Broken pipe errors are usually caused by connection</span>
                        <span class="c1"># reset, and its better to not log EPIPE errors to</span>
                        <span class="c1"># minimize log spam</span>
                        <span class="n">gen_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Write error on </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">e</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">return</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_futures</span><span class="p">:</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_futures</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_write_done_index</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_futures</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">future_set_result_unless_cancelled</span><span class="p">(</span><span class="n">future</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_consume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="c1"># Consume loc bytes from the read buffer and return them</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">loc</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span>
        <span class="c1"># Slice the bytearray buffer into bytes, without intermediate copying</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">memoryview</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span><span class="p">)[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span> <span class="o">+</span> <span class="n">loc</span>
            <span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span> <span class="o">+=</span> <span class="n">loc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="o">-=</span> <span class="n">loc</span>
        <span class="c1"># Amortized O(1) shrink</span>
        <span class="c1"># (this heuristic is implemented natively in Python 3.4+</span>
        <span class="c1">#  but is replicated here for Python 2)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">_check_closed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">StreamClosedError</span><span class="p">(</span><span class="n">real_error</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_maybe_add_error_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This method is part of an optimization: to detect a connection that</span>
        <span class="c1"># is closed when we&#39;re not actively reading or writing, we must listen</span>
        <span class="c1"># for read events.  However, it is inefficient to do this when the</span>
        <span class="c1"># connection is first established because we are going to read or write</span>
        <span class="c1"># immediately anyway.  Instead, we insert checks at various times to</span>
        <span class="c1"># see if the connection is idle and add the read listener then.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="n">ioloop</span><span class="o">.</span><span class="n">IOLoop</span><span class="o">.</span><span class="n">ERROR</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">()</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer_size</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_io_state</span><span class="p">(</span><span class="n">ioloop</span><span class="o">.</span><span class="n">IOLoop</span><span class="o">.</span><span class="n">READ</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_io_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds `state` (IOLoop.{READ,WRITE} flags) to our event handler.</span>

<span class="sd">        Implementation notes: Reads and writes have a fast path and a</span>
<span class="sd">        slow path.  The fast path reads synchronously from socket</span>
<span class="sd">        buffers, while the slow path uses `_add_io_state` to schedule</span>
<span class="sd">        an IOLoop callback.</span>

<span class="sd">        To detect closed connections, we must have called</span>
<span class="sd">        `_add_io_state` at some point, but we want to delay this as</span>
<span class="sd">        much as possible so we don&#39;t have to set an `IOLoop.ERROR`</span>
<span class="sd">        listener that will be overwritten by the next slow-path</span>
<span class="sd">        operation. If a sequence of fast-path ops do not end in a</span>
<span class="sd">        slow-path op, (e.g. for an @asynchronous long-poll request),</span>
<span class="sd">        we must add the error handler.</span>

<span class="sd">        TODO: reevaluate this now that callbacks are gone.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">():</span>
            <span class="c1"># connection has been closed, so there can be no future events</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">ioloop</span><span class="o">.</span><span class="n">IOLoop</span><span class="o">.</span><span class="n">ERROR</span> <span class="o">|</span> <span class="n">state</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_events</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">&amp;</span> <span class="n">state</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">|</span> <span class="n">state</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">update_handler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_connreset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span> <span class="ne">BaseException</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return ``True`` if exc is ECONNRESET or equivalent.</span>

<span class="sd">        May be overridden in subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">))</span>
            <span class="ow">and</span> <span class="n">errno_from_exception</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_ERRNO_CONNRESET</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="IOStream"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.IOStream">[docs]</a><span class="k">class</span> <span class="nc">IOStream</span><span class="p">(</span><span class="n">BaseIOStream</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Socket-based `IOStream` implementation.</span>

<span class="sd">    This class supports the read and write methods from `BaseIOStream`</span>
<span class="sd">    plus a `connect` method.</span>

<span class="sd">    The ``socket`` parameter may either be connected or unconnected.</span>
<span class="sd">    For server operations the socket is the result of calling</span>
<span class="sd">    `socket.accept &lt;socket.socket.accept&gt;`.  For client operations the</span>
<span class="sd">    socket is created with `socket.socket`, and may either be</span>
<span class="sd">    connected before passing it to the `IOStream` or connected with</span>
<span class="sd">    `IOStream.connect`.</span>

<span class="sd">    A very simple (and broken) HTTP client using this class:</span>

<span class="sd">    .. testcode::</span>

<span class="sd">        import tornado.ioloop</span>
<span class="sd">        import tornado.iostream</span>
<span class="sd">        import socket</span>

<span class="sd">        async def main():</span>
<span class="sd">            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)</span>
<span class="sd">            stream = tornado.iostream.IOStream(s)</span>
<span class="sd">            await stream.connect((&quot;friendfeed.com&quot;, 80))</span>
<span class="sd">            await stream.write(b&quot;GET / HTTP/1.0\r\nHost: friendfeed.com\r\n\r\n&quot;)</span>
<span class="sd">            header_data = await stream.read_until(b&quot;\r\n\r\n&quot;)</span>
<span class="sd">            headers = {}</span>
<span class="sd">            for line in header_data.split(b&quot;\r\n&quot;):</span>
<span class="sd">                parts = line.split(b&quot;:&quot;)</span>
<span class="sd">                if len(parts) == 2:</span>
<span class="sd">                    headers[parts[0].strip()] = parts[1].strip()</span>
<span class="sd">            body_data = await stream.read_bytes(int(headers[b&quot;Content-Length&quot;]))</span>
<span class="sd">            print(body_data)</span>
<span class="sd">            stream.close()</span>

<span class="sd">        if __name__ == &#39;__main__&#39;:</span>
<span class="sd">            tornado.ioloop.IOLoop.current().run_sync(main)</span>
<span class="sd">            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)</span>
<span class="sd">            stream = tornado.iostream.IOStream(s)</span>
<span class="sd">            stream.connect((&quot;friendfeed.com&quot;, 80), send_request)</span>
<span class="sd">            tornado.ioloop.IOLoop.current().start()</span>

<span class="sd">    .. testoutput::</span>
<span class="sd">       :hide:</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">socket</span><span class="p">:</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="o">=</span> <span class="n">socket</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IOStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ioloop</span><span class="o">.</span><span class="n">_Selectable</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span>

    <span class="k">def</span> <span class="nf">close_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span> <span class="nf">get_fd_error</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="ne">Exception</span><span class="p">]:</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">getsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_ERROR</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errno</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">read_from_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytearray</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">recv_into</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_ERRNO_WOULDBLOCK</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">buf</span>

    <span class="k">def</span> <span class="nf">write_to_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">memoryview</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Avoid keeping to data, which can be a memoryview.</span>
            <span class="c1"># See https://github.com/tornadoweb/tornado/pull/2008</span>
            <span class="k">del</span> <span class="n">data</span>

<div class="viewcode-block" id="IOStream.connect"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.IOStream.connect">[docs]</a>    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_IOStreamType</span><span class="p">,</span> <span class="n">address</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">server_hostname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Future[_IOStreamType]&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Connects the socket to a remote address without blocking.</span>

<span class="sd">        May only be called if the socket passed to the constructor was</span>
<span class="sd">        not previously connected.  The address parameter is in the</span>
<span class="sd">        same format as for `socket.connect &lt;socket.socket.connect&gt;` for</span>
<span class="sd">        the type of socket passed to the IOStream constructor,</span>
<span class="sd">        e.g. an ``(ip, port)`` tuple.  Hostnames are accepted here,</span>
<span class="sd">        but will be resolved synchronously and block the IOLoop.</span>
<span class="sd">        If you have a hostname instead of an IP address, the `.TCPClient`</span>
<span class="sd">        class is recommended instead of calling this method directly.</span>
<span class="sd">        `.TCPClient` will do asynchronous DNS resolution and handle</span>
<span class="sd">        both IPv4 and IPv6.</span>

<span class="sd">        If ``callback`` is specified, it will be called with no</span>
<span class="sd">        arguments when the connection is completed; if not this method</span>
<span class="sd">        returns a `.Future` (whose result after a successful</span>
<span class="sd">        connection will be the stream itself).</span>

<span class="sd">        In SSL mode, the ``server_hostname`` parameter will be used</span>
<span class="sd">        for certificate validation (unless disabled in the</span>
<span class="sd">        ``ssl_options``) and SNI (if supported; requires Python</span>
<span class="sd">        2.7.9+).</span>

<span class="sd">        Note that it is safe to call `IOStream.write</span>
<span class="sd">        &lt;BaseIOStream.write&gt;` while the connection is pending, in</span>
<span class="sd">        which case the data will be written as soon as the connection</span>
<span class="sd">        is ready.  Calling `IOStream` read methods before the socket is</span>
<span class="sd">        connected works on some platforms but is non-portable.</span>

<span class="sd">        .. versionchanged:: 4.0</span>
<span class="sd">            If no callback is given, returns a `.Future`.</span>

<span class="sd">        .. versionchanged:: 4.2</span>
<span class="sd">           SSL certificates are validated by default; pass</span>
<span class="sd">           ``ssl_options=dict(cert_reqs=ssl.CERT_NONE)`` or a</span>
<span class="sd">           suitably-configured `ssl.SSLContext` to the</span>
<span class="sd">           `SSLIOStream` constructor to disable.</span>

<span class="sd">        .. versionchanged:: 6.0</span>

<span class="sd">           The ``callback`` argument was removed. Use the returned</span>
<span class="sd">           `.Future` instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connecting</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>  <span class="c1"># type: Future[_IOStreamType]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connect_future</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;Future[IOStream]&quot;</span><span class="p">,</span> <span class="n">future</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># In non-blocking mode we expect connect() to raise an</span>
            <span class="c1"># exception with EINPROGRESS or EWOULDBLOCK.</span>
            <span class="c1">#</span>
            <span class="c1"># On freebsd, other errors such as ECONNREFUSED may be</span>
            <span class="c1"># returned immediately when attempting to connect to</span>
            <span class="c1"># localhost, so handle them the same way as an error</span>
            <span class="c1"># reported later in _handle_connect.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">errno_from_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_ERRNO_INPROGRESS</span>
                <span class="ow">and</span> <span class="n">errno_from_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_ERRNO_WOULDBLOCK</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">future</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">gen_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;Connect error on fd </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">e</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">future</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_io_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">WRITE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">future</span></div>

<div class="viewcode-block" id="IOStream.start_tls"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.IOStream.start_tls">[docs]</a>    <span class="k">def</span> <span class="nf">start_tls</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">server_side</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">ssl_options</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">server_hostname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="p">[</span><span class="s2">&quot;SSLIOStream&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Convert this `IOStream` to an `SSLIOStream`.</span>

<span class="sd">        This enables protocols that begin in clear-text mode and</span>
<span class="sd">        switch to SSL after some initial negotiation (such as the</span>
<span class="sd">        ``STARTTLS`` extension to SMTP and IMAP).</span>

<span class="sd">        This method cannot be used if there are outstanding reads</span>
<span class="sd">        or writes on the stream, or if there is any data in the</span>
<span class="sd">        IOStream&#39;s buffer (data in the operating system&#39;s socket</span>
<span class="sd">        buffer is allowed).  This means it must generally be used</span>
<span class="sd">        immediately after reading or writing the last clear-text</span>
<span class="sd">        data.  It can also be used immediately after connecting,</span>
<span class="sd">        before any reads or writes.</span>

<span class="sd">        The ``ssl_options`` argument may be either an `ssl.SSLContext`</span>
<span class="sd">        object or a dictionary of keyword arguments for the</span>
<span class="sd">        `ssl.wrap_socket` function.  The ``server_hostname`` argument</span>
<span class="sd">        will be used for certificate validation unless disabled</span>
<span class="sd">        in the ``ssl_options``.</span>

<span class="sd">        This method returns a `.Future` whose result is the new</span>
<span class="sd">        `SSLIOStream`.  After this method has been called,</span>
<span class="sd">        any other operation on the original stream is undefined.</span>

<span class="sd">        If a close callback is defined on this stream, it will be</span>
<span class="sd">        transferred to the new stream.</span>

<span class="sd">        .. versionadded:: 4.0</span>

<span class="sd">        .. versionchanged:: 4.2</span>
<span class="sd">           SSL certificates are validated by default; pass</span>
<span class="sd">           ``ssl_options=dict(cert_reqs=ssl.CERT_NONE)`` or a</span>
<span class="sd">           suitably-configured `ssl.SSLContext` to disable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_future</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_futures</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connect_future</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buffer</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_buffer</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;IOStream is not idle; cannot convert to SSL&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ssl_options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">server_side</span><span class="p">:</span>
                <span class="n">ssl_options</span> <span class="o">=</span> <span class="n">_server_ssl_defaults</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ssl_options</span> <span class="o">=</span> <span class="n">_client_ssl_defaults</span>

        <span class="n">socket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">remove_handler</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>
        <span class="n">socket</span> <span class="o">=</span> <span class="n">ssl_wrap_socket</span><span class="p">(</span>
            <span class="n">socket</span><span class="p">,</span>
            <span class="n">ssl_options</span><span class="p">,</span>
            <span class="n">server_hostname</span><span class="o">=</span><span class="n">server_hostname</span><span class="p">,</span>
            <span class="n">server_side</span><span class="o">=</span><span class="n">server_side</span><span class="p">,</span>
            <span class="n">do_handshake_on_connect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">orig_close_callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_callback</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">future</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>  <span class="c1"># type: Future[SSLIOStream]</span>
        <span class="n">ssl_stream</span> <span class="o">=</span> <span class="n">SSLIOStream</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">ssl_options</span><span class="o">=</span><span class="n">ssl_options</span><span class="p">)</span>
        <span class="n">ssl_stream</span><span class="o">.</span><span class="n">set_close_callback</span><span class="p">(</span><span class="n">orig_close_callback</span><span class="p">)</span>
        <span class="n">ssl_stream</span><span class="o">.</span><span class="n">_ssl_connect_future</span> <span class="o">=</span> <span class="n">future</span>
        <span class="n">ssl_stream</span><span class="o">.</span><span class="n">max_buffer_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_buffer_size</span>
        <span class="n">ssl_stream</span><span class="o">.</span><span class="n">read_chunk_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_chunk_size</span>
        <span class="k">return</span> <span class="n">future</span></div>

    <span class="k">def</span> <span class="nf">_handle_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">getsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_ERROR</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Hurd doesn&#39;t allow SO_ERROR for loopback sockets because all</span>
            <span class="c1"># errors for such sockets are reported synchronously.</span>
            <span class="k">if</span> <span class="n">errno_from_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">ENOPROTOOPT</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">strerror</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
            <span class="c1"># IOLoop implementations may vary: some of them return</span>
            <span class="c1"># an error state before the socket becomes writable, so</span>
            <span class="c1"># in that case a connection failure would be handled by the</span>
            <span class="c1"># error path in _handle_events instead of here.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connect_future</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gen_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Connect error on fd </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span>
                    <span class="n">errno</span><span class="o">.</span><span class="n">errorcode</span><span class="p">[</span><span class="n">err</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connect_future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connect_future</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connect_future</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">future_set_result_unless_cancelled</span><span class="p">(</span><span class="n">future</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connecting</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">set_nodelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">family</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span>
            <span class="n">socket</span><span class="o">.</span><span class="n">AF_INET6</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span>
                    <span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">TCP_NODELAY</span><span class="p">,</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">value</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># Sometimes setsockopt will fail if the socket is closed</span>
                <span class="c1"># at the wrong time.  This can happen with HTTPServer</span>
                <span class="c1"># resetting the value to ``False`` between requests.</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">EINVAL</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_connreset</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                    <span class="k">raise</span></div>


<div class="viewcode-block" id="SSLIOStream"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.SSLIOStream">[docs]</a><span class="k">class</span> <span class="nc">SSLIOStream</span><span class="p">(</span><span class="n">IOStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A utility class to write to and read from a non-blocking SSL socket.</span>

<span class="sd">    If the socket passed to the constructor is already connected,</span>
<span class="sd">    it should be wrapped with::</span>

<span class="sd">        ssl.wrap_socket(sock, do_handshake_on_connect=False, **kwargs)</span>

<span class="sd">    before constructing the `SSLIOStream`.  Unconnected sockets will be</span>
<span class="sd">    wrapped when `IOStream.connect` is finished.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">socket</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ssl.SSLSocket</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The ``ssl_options`` keyword argument may either be an</span>
<span class="sd">        `ssl.SSLContext` object or a dictionary of keywords arguments</span>
<span class="sd">        for `ssl.wrap_socket`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_options</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ssl_options&quot;</span><span class="p">,</span> <span class="n">_client_ssl_defaults</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SSLIOStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_accepting</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handshake_reading</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handshake_writing</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_server_hostname</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[str]</span>

        <span class="c1"># If the socket is already connected, attempt to start the handshake.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">getpeername</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Indirectly start the handshake, which will run on the next</span>
            <span class="c1"># IOLoop iteration and then the real IO state will be set in</span>
            <span class="c1"># _handle_events.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_io_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">WRITE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reading</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handshake_reading</span> <span class="ow">or</span> <span class="nb">super</span><span class="p">(</span><span class="n">SSLIOStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reading</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">writing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handshake_writing</span> <span class="ow">or</span> <span class="nb">super</span><span class="p">(</span><span class="n">SSLIOStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">writing</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_do_ssl_handshake</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Based on code from test_ssl.py in the python stdlib</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handshake_reading</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handshake_writing</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">do_handshake</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_WANT_READ</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handshake_reading</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_WANT_WRITE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handshake_writing</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_EOF</span><span class="p">,</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_ZERO_RETURN</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">err</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_SSL</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">peer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">getpeername</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">peer</span> <span class="o">=</span> <span class="s2">&quot;(not connected)&quot;</span>
                <span class="n">gen_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;SSL Error on </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">peer</span><span class="p">,</span> <span class="n">err</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">err</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="c1"># Some port scans (e.g. nmap in -sT mode) have been known</span>
            <span class="c1"># to cause do_handshake to raise EBADF and ENOTCONN, so make</span>
            <span class="c1"># those errors quiet as well.</span>
            <span class="c1"># https://groups.google.com/forum/?fromgroups#!topic/python-tornado/ApucKJat1_0</span>
            <span class="c1"># Errno 0 is also possible in some cases (nc -z).</span>
            <span class="c1"># https://github.com/tornadoweb/tornado/issues/2504</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_connreset</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="ow">or</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">errno</span><span class="o">.</span><span class="n">EBADF</span><span class="p">,</span>
                <span class="n">errno</span><span class="o">.</span><span class="n">ENOTCONN</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">err</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="c1"># On Linux, if the connection was reset before the call to</span>
            <span class="c1"># wrap_socket, do_handshake will fail with an</span>
            <span class="c1"># AttributeError.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">err</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_accepting</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verify_cert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">getpeercert</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_finish_ssl_connect</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_finish_ssl_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_connect_future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_connect_future</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_connect_future</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">future_set_result_unless_cancelled</span><span class="p">(</span><span class="n">future</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_cert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peercert</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns ``True`` if peercert is valid according to the configured</span>
<span class="sd">        validation mode and hostname.</span>

<span class="sd">        The ssl handshake already tested the certificate for a valid</span>
<span class="sd">        CA signature; the only thing that remains is to check</span>
<span class="sd">        the hostname.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ssl_options</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">verify_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cert_reqs&quot;</span><span class="p">,</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_NONE</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ssl_options</span><span class="p">,</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">):</span>
            <span class="n">verify_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_options</span><span class="o">.</span><span class="n">verify_mode</span>
        <span class="k">assert</span> <span class="n">verify_mode</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">CERT_NONE</span><span class="p">,</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span><span class="p">,</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_OPTIONAL</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verify_mode</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_NONE</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_server_hostname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">cert</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">getpeercert</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cert</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">verify_mode</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span><span class="p">:</span>
            <span class="n">gen_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No SSL certificate given&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">peercert</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_server_hostname</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CertificateError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">gen_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Invalid SSL certificate: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_handle_read</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_accepting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_do_ssl_handshake</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SSLIOStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_handle_read</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_handle_write</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_accepting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_do_ssl_handshake</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SSLIOStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_handle_write</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">server_hostname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Future[SSLIOStream]&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_server_hostname</span> <span class="o">=</span> <span class="n">server_hostname</span>
        <span class="c1"># Ignore the result of connect(). If it fails,</span>
        <span class="c1"># wait_for_handshake will raise an error too. This is</span>
        <span class="c1"># necessary for the old semantics of the connect callback</span>
        <span class="c1"># (which takes no arguments). In 6.0 this can be refactored to</span>
        <span class="c1"># be a regular coroutine.</span>
        <span class="c1"># TODO: This is trickier than it looks, since if write()</span>
        <span class="c1"># is called with a connect() pending, we want the connect</span>
        <span class="c1"># to resolve before the write. Or do we care about this?</span>
        <span class="c1"># (There&#39;s a test for it, but I think in practice users</span>
        <span class="c1"># either wait for the connect before performing a write or</span>
        <span class="c1"># they don&#39;t care about the connect Future at all)</span>
        <span class="n">fut</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">SSLIOStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
        <span class="n">fut</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">exception</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_handshake</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_handle_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Call the superclass method to check for errors.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SSLIOStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_handle_connect</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="c1"># When the connection is complete, wrap the socket for SSL</span>
        <span class="c1"># traffic.  Note that we do this by overriding _handle_connect</span>
        <span class="c1"># instead of by passing a callback to super().connect because</span>
        <span class="c1"># user callbacks are enqueued asynchronously on the IOLoop,</span>
        <span class="c1"># but since _handle_events calls _handle_connect immediately</span>
        <span class="c1"># followed by _handle_write we need this to be synchronous.</span>
        <span class="c1">#</span>
        <span class="c1"># The IOLoop will get confused if we swap out self.socket while the</span>
        <span class="c1"># fd is registered, so remove it now and re-register after</span>
        <span class="c1"># wrap_socket().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">remove_handler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="p">)</span>
        <span class="n">old_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>
        <span class="k">assert</span> <span class="n">old_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="o">=</span> <span class="n">ssl_wrap_socket</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_options</span><span class="p">,</span>
            <span class="n">server_hostname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_server_hostname</span><span class="p">,</span>
            <span class="n">do_handshake_on_connect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_io_state</span><span class="p">(</span><span class="n">old_state</span><span class="p">)</span>

<div class="viewcode-block" id="SSLIOStream.wait_for_handshake"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.SSLIOStream.wait_for_handshake">[docs]</a>    <span class="k">def</span> <span class="nf">wait_for_handshake</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Future[SSLIOStream]&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Wait for the initial SSL handshake to complete.</span>

<span class="sd">        If a ``callback`` is given, it will be called with no</span>
<span class="sd">        arguments once the handshake is complete; otherwise this</span>
<span class="sd">        method returns a `.Future` which will resolve to the</span>
<span class="sd">        stream itself after the handshake is complete.</span>

<span class="sd">        Once the handshake is complete, information such as</span>
<span class="sd">        the peer&#39;s certificate and NPN/ALPN selections may be</span>
<span class="sd">        accessed on ``self.socket``.</span>

<span class="sd">        This method is intended for use on server-side streams</span>
<span class="sd">        or after using `IOStream.start_tls`; it should not be used</span>
<span class="sd">        with `IOStream.connect` (which already waits for the</span>
<span class="sd">        handshake to complete). It may only be called once per stream.</span>

<span class="sd">        .. versionadded:: 4.2</span>

<span class="sd">        .. versionchanged:: 6.0</span>

<span class="sd">           The ``callback`` argument was removed. Use the returned</span>
<span class="sd">           `.Future` instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_connect_future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Already waiting&quot;</span><span class="p">)</span>
        <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_connect_future</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_accepting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_finish_ssl_connect</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">future</span></div>

    <span class="k">def</span> <span class="nf">write_to_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">memoryview</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_WANT_WRITE</span><span class="p">:</span>
                <span class="c1"># In Python 3.5+, SSLSocket.send raises a WANT_WRITE error if</span>
                <span class="c1"># the socket is not writeable; we need to transform this into</span>
                <span class="c1"># an EWOULDBLOCK socket.error or a zero return value,</span>
                <span class="c1"># either of which will be recognized by the caller of this</span>
                <span class="c1"># method. Prior to Python 3.5, an unwriteable socket would</span>
                <span class="c1"># simply return 0 bytes written.</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">raise</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Avoid keeping to data, which can be a memoryview.</span>
            <span class="c1"># See https://github.com/tornadoweb/tornado/pull/2008</span>
            <span class="k">del</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">read_from_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytearray</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssl_accepting</span><span class="p">:</span>
                <span class="c1"># If the handshake hasn&#39;t finished yet, there can&#39;t be anything</span>
                <span class="c1"># to read (attempting to read may or may not raise an exception</span>
                <span class="c1"># depending on the SSL version)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">recv_into</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># SSLError is a subclass of socket.error, so this except</span>
                <span class="c1"># block must come first.</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_WANT_READ</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>
            <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_ERRNO_WOULDBLOCK</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">buf</span>

    <span class="k">def</span> <span class="nf">_is_connreset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="ne">BaseException</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLError</span><span class="p">)</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_EOF</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SSLIOStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_is_connreset</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div>


<div class="viewcode-block" id="PipeIOStream"><a class="viewcode-back" href="../../iostream.html#tornado.iostream.PipeIOStream">[docs]</a><span class="k">class</span> <span class="nc">PipeIOStream</span><span class="p">(</span><span class="n">BaseIOStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pipe-based `IOStream` implementation.</span>

<span class="sd">    The constructor takes an integer file descriptor (such as one returned</span>
<span class="sd">    by `os.pipe`) rather than an open file object.  Pipes are generally</span>
<span class="sd">    one-way, so a `PipeIOStream` can be used for reading or writing but not</span>
<span class="sd">    both.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fio</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">FileIO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span>
        <span class="n">_set_nonblocking</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PipeIOStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fd</span>

    <span class="k">def</span> <span class="nf">close_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fio</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">write_to_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">memoryview</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Avoid keeping to data, which can be a memoryview.</span>
            <span class="c1"># See https://github.com/tornadoweb/tornado/pull/2008</span>
            <span class="k">del</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">read_from_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytearray</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fio</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">errno_from_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EBADF</span><span class="p">:</span>
                <span class="c1"># If the writing half of a pipe is closed, select will</span>
                <span class="c1"># report it as readable but reads will fail with EBADF.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">exc_info</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">buf</span></div>


<span class="k">def</span> <span class="nf">doctests</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>

    <span class="k">return</span> <span class="n">doctest</span><span class="o">.</span><span class="n">DocTestSuite</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The Tornado Authors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>