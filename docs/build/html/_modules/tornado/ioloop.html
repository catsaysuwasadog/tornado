

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tornado.ioloop &mdash; Tornado 6.1.dev1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Tornado
          

          
          </a>

          
            
            
              <div class="version">
                6.1.dev1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../guide.html">Userâ€™s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../webframework.html">Web framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../http.html">HTTP servers and clients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking.html">Asynchronous networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../coroutine.html">Coroutines and concurrency</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../integration.html">Integration with other services</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../releases.html">Release notes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Tornado</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>tornado.ioloop</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tornado.ioloop</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Copyright 2009 Facebook</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="c1"># not use this file except in compliance with the License. You may obtain</span>
<span class="c1"># a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="c1"># WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="c1"># License for the specific language governing permissions and limitations</span>
<span class="c1"># under the License.</span>

<span class="sd">&quot;&quot;&quot;An I/O event loop for non-blocking sockets.</span>

<span class="sd">In Tornado 6.0, `.IOLoop` is a wrapper around the `asyncio` event</span>
<span class="sd">loop, with a slightly different interface for historical reasons.</span>
<span class="sd">Applications can use either the `.IOLoop` interface or the underlying</span>
<span class="sd">`asyncio` event loop directly (unless compatibility with older</span>
<span class="sd">versions of Tornado is desired, in which case `.IOLoop` must be used).</span>

<span class="sd">Typical applications will use a single `IOLoop` object, accessed via</span>
<span class="sd">`IOLoop.current` class method. The `IOLoop.start` method (or</span>
<span class="sd">equivalently, `asyncio.AbstractEventLoop.run_forever`) should usually</span>
<span class="sd">be called at the end of the ``main()`` function. Atypical applications</span>
<span class="sd">may use more than one `IOLoop`, such as one `IOLoop` per thread, or</span>
<span class="sd">per `unittest` case.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">from</span> <span class="nn">tornado.concurrent</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Future</span><span class="p">,</span>
    <span class="n">is_future</span><span class="p">,</span>
    <span class="n">chain_future</span><span class="p">,</span>
    <span class="n">future_set_exc_info</span><span class="p">,</span>
    <span class="n">future_add_done_callback</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">tornado.log</span> <span class="k">import</span> <span class="n">app_log</span>
<span class="kn">from</span> <span class="nn">tornado.util</span> <span class="k">import</span> <span class="n">Configurable</span><span class="p">,</span> <span class="ne">TimeoutError</span><span class="p">,</span> <span class="n">import_object</span>

<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Awaitable</span>

<span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span>  <span class="c1"># noqa: F401</span>

    <span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="k">import</span> <span class="n">Protocol</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">Protocol</span> <span class="o">=</span> <span class="nb">object</span>


<span class="k">class</span> <span class="nc">_Selectable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="n">_T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_T&quot;</span><span class="p">)</span>
<span class="n">_S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_S&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">_Selectable</span><span class="p">)</span>


<div class="viewcode-block" id="IOLoop"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop">[docs]</a><span class="k">class</span> <span class="nc">IOLoop</span><span class="p">(</span><span class="n">Configurable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An I/O event loop.</span>

<span class="sd">    As of Tornado 6.0, `IOLoop` is a wrapper around the `asyncio` event</span>
<span class="sd">    loop.</span>

<span class="sd">    Example usage for a simple TCP server:</span>

<span class="sd">    .. testcode::</span>

<span class="sd">        import errno</span>
<span class="sd">        import functools</span>
<span class="sd">        import socket</span>

<span class="sd">        import tornado.ioloop</span>
<span class="sd">        from tornado.iostream import IOStream</span>

<span class="sd">        async def handle_connection(connection, address):</span>
<span class="sd">            stream = IOStream(connection)</span>
<span class="sd">            message = await stream.read_until_close()</span>
<span class="sd">            print(&quot;message from client:&quot;, message.decode().strip())</span>

<span class="sd">        def connection_ready(sock, fd, events):</span>
<span class="sd">            while True:</span>
<span class="sd">                try:</span>
<span class="sd">                    connection, address = sock.accept()</span>
<span class="sd">                except socket.error as e:</span>
<span class="sd">                    if e.args[0] not in (errno.EWOULDBLOCK, errno.EAGAIN):</span>
<span class="sd">                        raise</span>
<span class="sd">                    return</span>
<span class="sd">                connection.setblocking(0)</span>
<span class="sd">                io_loop = tornado.ioloop.IOLoop.current()</span>
<span class="sd">                io_loop.spawn_callback(handle_connection, connection, address)</span>

<span class="sd">        if __name__ == &#39;__main__&#39;:</span>
<span class="sd">            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)</span>
<span class="sd">            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span>
<span class="sd">            sock.setblocking(0)</span>
<span class="sd">            sock.bind((&quot;&quot;, 8888))</span>
<span class="sd">            sock.listen(128)</span>

<span class="sd">            io_loop = tornado.ioloop.IOLoop.current()</span>
<span class="sd">            callback = functools.partial(connection_ready, sock)</span>
<span class="sd">            io_loop.add_handler(sock.fileno(), callback, io_loop.READ)</span>
<span class="sd">            io_loop.start()</span>

<span class="sd">    .. testoutput::</span>
<span class="sd">       :hide:</span>

<span class="sd">    By default, a newly-constructed `IOLoop` becomes the thread&#39;s current</span>
<span class="sd">    `IOLoop`, unless there already is a current `IOLoop`. This behavior</span>
<span class="sd">    can be controlled with the ``make_current`` argument to the `IOLoop`</span>
<span class="sd">    constructor: if ``make_current=True``, the new `IOLoop` will always</span>
<span class="sd">    try to become current and it raises an error if there is already a</span>
<span class="sd">    current instance. If ``make_current=False``, the new `IOLoop` will</span>
<span class="sd">    not try to become current.</span>

<span class="sd">    In general, an `IOLoop` cannot survive a fork or be shared across</span>
<span class="sd">    processes in any way. When multiple processes are being used, each</span>
<span class="sd">    process should create its own `IOLoop`, which also implies that</span>
<span class="sd">    any objects which depend on the `IOLoop` (such as</span>
<span class="sd">    `.AsyncHTTPClient`) must also be created in the child processes.</span>
<span class="sd">    As a guideline, anything that starts processes (including the</span>
<span class="sd">    `tornado.process` and `multiprocessing` modules) should do so as</span>
<span class="sd">    early as possible, ideally the first thing the application does</span>
<span class="sd">    after loading its configuration in ``main()``.</span>

<span class="sd">    .. versionchanged:: 4.2</span>
<span class="sd">       Added the ``make_current`` keyword argument to the `IOLoop`</span>
<span class="sd">       constructor.</span>

<span class="sd">    .. versionchanged:: 5.0</span>

<span class="sd">       Uses the `asyncio` event loop by default. The</span>
<span class="sd">       ``IOLoop.configure`` method cannot be used on Python 3 except</span>
<span class="sd">       to redundantly specify the `asyncio` event loop.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># These constants were originally based on constants from the epoll module.</span>
    <span class="n">NONE</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">READ</span> <span class="o">=</span> <span class="mh">0x001</span>
    <span class="n">WRITE</span> <span class="o">=</span> <span class="mh">0x004</span>
    <span class="n">ERROR</span> <span class="o">=</span> <span class="mh">0x018</span>

    <span class="c1"># In Python 3, _ioloop_for_asyncio maps from asyncio loops to IOLoops.</span>
    <span class="n">_ioloop_for_asyncio</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># type: Dict[asyncio.AbstractEventLoop, IOLoop]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">impl</span><span class="p">:</span> <span class="s2">&quot;Union[None, str, Type[Configurable]]&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">asyncio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">tornado.platform.asyncio</span> <span class="k">import</span> <span class="n">BaseAsyncIOLoop</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">impl</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">impl</span> <span class="o">=</span> <span class="n">import_object</span><span class="p">(</span><span class="n">impl</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">impl</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">impl</span><span class="p">,</span> <span class="n">BaseAsyncIOLoop</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;only AsyncIOLoop is allowed when asyncio is available&quot;</span>
                <span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IOLoop</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="n">impl</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="IOLoop.instance"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.instance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">instance</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;IOLoop&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated alias for `IOLoop.current()`.</span>

<span class="sd">        .. versionchanged:: 5.0</span>

<span class="sd">           Previously, this method returned a global singleton</span>
<span class="sd">           `IOLoop`, in contrast with the per-thread `IOLoop` returned</span>
<span class="sd">           by `current()`. In nearly all cases the two were the same</span>
<span class="sd">           (when they differed, it was generally used from non-Tornado</span>
<span class="sd">           threads to communicate back to the main thread&#39;s `IOLoop`).</span>
<span class="sd">           This distinction is not present in `asyncio`, so in order</span>
<span class="sd">           to facilitate integration with that package `instance()`</span>
<span class="sd">           was changed to be an alias to `current()`. Applications</span>
<span class="sd">           using the cross-thread communications aspect of</span>
<span class="sd">           `instance()` should instead set their own global variable</span>
<span class="sd">           to point to the `IOLoop` they want to use.</span>

<span class="sd">        .. deprecated:: 5.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IOLoop</span><span class="o">.</span><span class="n">current</span><span class="p">()</span></div>

<div class="viewcode-block" id="IOLoop.install"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.install">[docs]</a>    <span class="k">def</span> <span class="nf">install</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated alias for `make_current()`.</span>

<span class="sd">        .. versionchanged:: 5.0</span>

<span class="sd">           Previously, this method would set this `IOLoop` as the</span>
<span class="sd">           global singleton used by `IOLoop.instance()`. Now that</span>
<span class="sd">           `instance()` is an alias for `current()`, `install()`</span>
<span class="sd">           is an alias for `make_current()`.</span>

<span class="sd">        .. deprecated:: 5.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_current</span><span class="p">()</span></div>

<div class="viewcode-block" id="IOLoop.clear_instance"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.clear_instance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">clear_instance</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated alias for `clear_current()`.</span>

<span class="sd">        .. versionchanged:: 5.0</span>

<span class="sd">           Previously, this method would clear the `IOLoop` used as</span>
<span class="sd">           the global singleton by `IOLoop.instance()`. Now that</span>
<span class="sd">           `instance()` is an alias for `current()`,</span>
<span class="sd">           `clear_instance()` is an alias for `clear_current()`.</span>

<span class="sd">        .. deprecated:: 5.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">IOLoop</span><span class="o">.</span><span class="n">clear_current</span><span class="p">()</span></div>

    <span class="nd">@typing</span><span class="o">.</span><span class="n">overload</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">current</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;IOLoop&quot;</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@typing</span><span class="o">.</span><span class="n">overload</span>  <span class="c1"># noqa: F811</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">current</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;IOLoop&quot;</span><span class="p">]:</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="IOLoop.current"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.current">[docs]</a>    <span class="nd">@staticmethod</span>  <span class="c1"># noqa: F811</span>
    <span class="k">def</span> <span class="nf">current</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;IOLoop&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns the current thread&#39;s `IOLoop`.</span>

<span class="sd">        If an `IOLoop` is currently running or has been marked as</span>
<span class="sd">        current by `make_current`, returns that instance.  If there is</span>
<span class="sd">        no current `IOLoop` and ``instance`` is true, creates one.</span>

<span class="sd">        .. versionchanged:: 4.1</span>
<span class="sd">           Added ``instance`` argument to control the fallback to</span>
<span class="sd">           `IOLoop.instance()`.</span>
<span class="sd">        .. versionchanged:: 5.0</span>
<span class="sd">           On Python 3, control of the current `IOLoop` is delegated</span>
<span class="sd">           to `asyncio`, with this and other methods as pass-through accessors.</span>
<span class="sd">           The ``instance`` argument now controls whether an `IOLoop`</span>
<span class="sd">           is created automatically when there is none, instead of</span>
<span class="sd">           whether we fall back to `IOLoop.instance()` (which is now</span>
<span class="sd">           an alias for this method). ``instance=False`` is deprecated,</span>
<span class="sd">           since even if we do not create an `IOLoop`, this method</span>
<span class="sd">           may initialize the asyncio loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">instance</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">raise</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IOLoop</span><span class="o">.</span><span class="n">_ioloop_for_asyncio</span><span class="p">[</span><span class="n">loop</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">instance</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">tornado.platform.asyncio</span> <span class="k">import</span> <span class="n">AsyncIOMainLoop</span>

                <span class="n">current</span> <span class="o">=</span> <span class="n">AsyncIOMainLoop</span><span class="p">(</span><span class="n">make_current</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># type: Optional[IOLoop]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">current</span></div>

<div class="viewcode-block" id="IOLoop.make_current"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.make_current">[docs]</a>    <span class="k">def</span> <span class="nf">make_current</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Makes this the `IOLoop` for the current thread.</span>

<span class="sd">        An `IOLoop` automatically becomes current for its thread</span>
<span class="sd">        when it is started, but it is sometimes useful to call</span>
<span class="sd">        `make_current` explicitly before starting the `IOLoop`,</span>
<span class="sd">        so that code run at startup time can find the right</span>
<span class="sd">        instance.</span>

<span class="sd">        .. versionchanged:: 4.1</span>
<span class="sd">           An `IOLoop` created while there is no current `IOLoop`</span>
<span class="sd">           will automatically become current.</span>

<span class="sd">        .. versionchanged:: 5.0</span>
<span class="sd">           This method also sets the current `asyncio` event loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The asyncio event loops override this method.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="IOLoop.clear_current"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.clear_current">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">clear_current</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Clears the `IOLoop` for the current thread.</span>

<span class="sd">        Intended primarily for use by test frameworks in between tests.</span>

<span class="sd">        .. versionchanged:: 5.0</span>
<span class="sd">           This method also clears the current `asyncio` event loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">IOLoop</span><span class="o">.</span><span class="n">current</span><span class="p">(</span><span class="n">instance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">old</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">old</span><span class="o">.</span><span class="n">_clear_current_hook</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">asyncio</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">IOLoop</span><span class="o">.</span><span class="n">_current</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_clear_current_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Instance method called when an IOLoop ceases to be current.</span>

<span class="sd">        May be overridden by subclasses as a counterpart to make_current.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">configurable_base</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">Configurable</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">IOLoop</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">configurable_default</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">Configurable</span><span class="p">]:</span>
        <span class="kn">from</span> <span class="nn">tornado.platform.asyncio</span> <span class="k">import</span> <span class="n">AsyncIOLoop</span>

        <span class="k">return</span> <span class="n">AsyncIOLoop</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">make_current</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">make_current</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">IOLoop</span><span class="o">.</span><span class="n">current</span><span class="p">(</span><span class="n">instance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">make_current</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">make_current</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">IOLoop</span><span class="o">.</span><span class="n">current</span><span class="p">(</span><span class="n">instance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># AsyncIO loops can already be current by this point.</span>
            <span class="k">if</span> <span class="n">current</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">current</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;current IOLoop already exists&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_current</span><span class="p">()</span>

<div class="viewcode-block" id="IOLoop.close"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_fds</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Closes the `IOLoop`, freeing any resources used.</span>

<span class="sd">        If ``all_fds`` is true, all file descriptors registered on the</span>
<span class="sd">        IOLoop will be closed (not just the ones created by the</span>
<span class="sd">        `IOLoop` itself).</span>

<span class="sd">        Many applications will only use a single `IOLoop` that runs for the</span>
<span class="sd">        entire lifetime of the process.  In that case closing the `IOLoop`</span>
<span class="sd">        is not necessary since everything will be cleaned up when the</span>
<span class="sd">        process exits.  `IOLoop.close` is provided mainly for scenarios</span>
<span class="sd">        such as unit tests, which create and destroy a large number of</span>
<span class="sd">        ``IOLoops``.</span>

<span class="sd">        An `IOLoop` must be completely stopped before it can be closed.  This</span>
<span class="sd">        means that `IOLoop.stop()` must be called *and* `IOLoop.start()` must</span>
<span class="sd">        be allowed to return before attempting to call `IOLoop.close()`.</span>
<span class="sd">        Therefore the call to `close` will usually appear just after</span>
<span class="sd">        the call to `start` rather than near the call to `stop`.</span>

<span class="sd">        .. versionchanged:: 3.1</span>
<span class="sd">           If the `IOLoop` implementation supports non-integer objects</span>
<span class="sd">           for &quot;file descriptors&quot;, those objects will have their</span>
<span class="sd">           ``close`` method when ``all_fds`` is true.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

    <span class="nd">@typing</span><span class="o">.</span><span class="n">overload</span>
    <span class="k">def</span> <span class="nf">add_handler</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span> <span class="n">events</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@typing</span><span class="o">.</span><span class="n">overload</span>  <span class="c1"># noqa: F811</span>
    <span class="k">def</span> <span class="nf">add_handler</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">:</span> <span class="n">_S</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">_S</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span> <span class="n">events</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="IOLoop.add_handler"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.add_handler">[docs]</a>    <span class="k">def</span> <span class="nf">add_handler</span><span class="p">(</span>  <span class="c1"># noqa: F811</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">_Selectable</span><span class="p">],</span> <span class="n">handler</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">events</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Registers the given handler to receive the given events for ``fd``.</span>

<span class="sd">        The ``fd`` argument may either be an integer file descriptor or</span>
<span class="sd">        a file-like object with a ``fileno()`` and ``close()`` method.</span>

<span class="sd">        The ``events`` argument is a bitwise or of the constants</span>
<span class="sd">        ``IOLoop.READ``, ``IOLoop.WRITE``, and ``IOLoop.ERROR``.</span>

<span class="sd">        When an event occurs, ``handler(fd, events)`` will be run.</span>

<span class="sd">        .. versionchanged:: 4.0</span>
<span class="sd">           Added the ability to pass file-like objects in addition to</span>
<span class="sd">           raw file descriptors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="IOLoop.update_handler"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.update_handler">[docs]</a>    <span class="k">def</span> <span class="nf">update_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">_Selectable</span><span class="p">],</span> <span class="n">events</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Changes the events we listen for ``fd``.</span>

<span class="sd">        .. versionchanged:: 4.0</span>
<span class="sd">           Added the ability to pass file-like objects in addition to</span>
<span class="sd">           raw file descriptors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="IOLoop.remove_handler"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.remove_handler">[docs]</a>    <span class="k">def</span> <span class="nf">remove_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">_Selectable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Stop listening for events on ``fd``.</span>

<span class="sd">        .. versionchanged:: 4.0</span>
<span class="sd">           Added the ability to pass file-like objects in addition to</span>
<span class="sd">           raw file descriptors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="IOLoop.start"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Starts the I/O loop.</span>

<span class="sd">        The loop will run until one of the callbacks calls `stop()`, which</span>
<span class="sd">        will make the loop stop after the current event iteration completes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_setup_logging</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The IOLoop catches and logs exceptions, so it&#39;s</span>
<span class="sd">        important that log output be visible.  However, python&#39;s</span>
<span class="sd">        default behavior for non-root loggers (prior to python</span>
<span class="sd">        3.2) is to print an unhelpful &quot;no handlers could be</span>
<span class="sd">        found&quot; message rather than the actual log entry, so we</span>
<span class="sd">        must explicitly configure logging if we&#39;ve made it this</span>
<span class="sd">        far without anything.</span>

<span class="sd">        This method should be called from start() in subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">handlers</span><span class="p">,</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;tornado&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">handlers</span><span class="p">,</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;tornado.application&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">handlers</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">()</span>

<div class="viewcode-block" id="IOLoop.stop"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.stop">[docs]</a>    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Stop the I/O loop.</span>

<span class="sd">        If the event loop is not currently running, the next call to `start()`</span>
<span class="sd">        will return immediately.</span>

<span class="sd">        Note that even after `stop` has been called, the `IOLoop` is not</span>
<span class="sd">        completely stopped until `IOLoop.start` has also returned.</span>
<span class="sd">        Some work that was scheduled before the call to `stop` may still</span>
<span class="sd">        be run before the `IOLoop` shuts down.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="IOLoop.run_sync"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.run_sync">[docs]</a>    <span class="k">def</span> <span class="nf">run_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Starts the `IOLoop`, runs the given function, and stops the loop.</span>

<span class="sd">        The function must return either an awaitable object or</span>
<span class="sd">        ``None``. If the function returns an awaitable object, the</span>
<span class="sd">        `IOLoop` will run until the awaitable is resolved (and</span>
<span class="sd">        `run_sync()` will return the awaitable&#39;s result). If it raises</span>
<span class="sd">        an exception, the `IOLoop` will stop and the exception will be</span>
<span class="sd">        re-raised to the caller.</span>

<span class="sd">        The keyword-only argument ``timeout`` may be used to set</span>
<span class="sd">        a maximum duration for the function.  If the timeout expires,</span>
<span class="sd">        a `tornado.util.TimeoutError` is raised.</span>

<span class="sd">        This method is useful to allow asynchronous calls in a</span>
<span class="sd">        ``main()`` function::</span>

<span class="sd">            async def main():</span>
<span class="sd">                # do stuff...</span>

<span class="sd">            if __name__ == &#39;__main__&#39;:</span>
<span class="sd">                IOLoop.current().run_sync(main)</span>

<span class="sd">        .. versionchanged:: 4.3</span>
<span class="sd">           Returning a non-``None``, non-awaitable value is now an error.</span>

<span class="sd">        .. versionchanged:: 5.0</span>
<span class="sd">           If a timeout occurs, the ``func`` coroutine will be cancelled.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">future_cell</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>  <span class="c1"># type: List[Optional[Future]]</span>

        <span class="k">def</span> <span class="nf">run</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">tornado.gen</span> <span class="k">import</span> <span class="n">convert_yielded</span>

                    <span class="n">result</span> <span class="o">=</span> <span class="n">convert_yielded</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">fut</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>  <span class="c1"># type: Future[Any]</span>
                <span class="n">future_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fut</span>
                <span class="n">future_set_exc_info</span><span class="p">(</span><span class="n">fut</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_future</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                    <span class="n">future_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fut</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>
                    <span class="n">future_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fut</span>
                    <span class="n">fut</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">future_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_future</span><span class="p">(</span><span class="n">future_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">future</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">run</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">timeout_callback</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If we can cancel the future, do so and wait on it. If not,</span>
                <span class="c1"># Just stop the loop and return with the task still pending.</span>
                <span class="c1"># (If we neither cancel nor wait for the task, a warning</span>
                <span class="c1"># will be logged).</span>
                <span class="k">assert</span> <span class="n">future_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">future_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cancel</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

            <span class="n">timeout_handle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">timeout_callback</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_timeout</span><span class="p">(</span><span class="n">timeout_handle</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">future_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">future_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cancelled</span><span class="p">()</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">future_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TimeoutError</span><span class="p">(</span><span class="s2">&quot;Operation timed out after </span><span class="si">%s</span><span class="s2"> seconds&quot;</span> <span class="o">%</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">future_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">result</span><span class="p">()</span></div>

<div class="viewcode-block" id="IOLoop.time"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.time">[docs]</a>    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the current time according to the `IOLoop`&#39;s clock.</span>

<span class="sd">        The return value is a floating-point number relative to an</span>
<span class="sd">        unspecified time in the past.</span>

<span class="sd">        Historically, the IOLoop could be customized to use e.g.</span>
<span class="sd">        `time.monotonic` instead of `time.time`, but this is not</span>
<span class="sd">        currently supported and so this method is equivalent to</span>
<span class="sd">        `time.time`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span></div>

<div class="viewcode-block" id="IOLoop.add_timeout"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.add_timeout">[docs]</a>    <span class="k">def</span> <span class="nf">add_timeout</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">deadline</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">],</span>
        <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Runs the ``callback`` at the time ``deadline`` from the I/O loop.</span>

<span class="sd">        Returns an opaque handle that may be passed to</span>
<span class="sd">        `remove_timeout` to cancel.</span>

<span class="sd">        ``deadline`` may be a number denoting a time (on the same</span>
<span class="sd">        scale as `IOLoop.time`, normally `time.time`), or a</span>
<span class="sd">        `datetime.timedelta` object for a deadline relative to the</span>
<span class="sd">        current time.  Since Tornado 4.0, `call_later` is a more</span>
<span class="sd">        convenient alternative for the relative case since it does not</span>
<span class="sd">        require a timedelta object.</span>

<span class="sd">        Note that it is not safe to call `add_timeout` from other threads.</span>
<span class="sd">        Instead, you must use `add_callback` to transfer control to the</span>
<span class="sd">        `IOLoop`&#39;s thread, and then call `add_timeout` from there.</span>

<span class="sd">        Subclasses of IOLoop must implement either `add_timeout` or</span>
<span class="sd">        `call_at`; the default implementations of each will call</span>
<span class="sd">        the other.  `call_at` is usually easier to implement, but</span>
<span class="sd">        subclasses that wish to maintain compatibility with Tornado</span>
<span class="sd">        versions prior to 4.0 must use `add_timeout` instead.</span>

<span class="sd">        .. versionchanged:: 4.0</span>
<span class="sd">           Now passes through ``*args`` and ``**kwargs`` to the callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">deadline</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_at</span><span class="p">(</span><span class="n">deadline</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">deadline</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_at</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">deadline</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">(),</span> <span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported deadline </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">deadline</span><span class="p">)</span></div>

<div class="viewcode-block" id="IOLoop.call_later"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.call_later">[docs]</a>    <span class="k">def</span> <span class="nf">call_later</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Runs the ``callback`` after ``delay`` seconds have passed.</span>

<span class="sd">        Returns an opaque handle that may be passed to `remove_timeout`</span>
<span class="sd">        to cancel.  Note that unlike the `asyncio` method of the same</span>
<span class="sd">        name, the returned object does not have a ``cancel()`` method.</span>

<span class="sd">        See `add_timeout` for comments on thread-safety and subclassing.</span>

<span class="sd">        .. versionadded:: 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">delay</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="IOLoop.call_at"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.call_at">[docs]</a>    <span class="k">def</span> <span class="nf">call_at</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">when</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Runs the ``callback`` at the absolute time designated by ``when``.</span>

<span class="sd">        ``when`` must be a number using the same reference point as</span>
<span class="sd">        `IOLoop.time`.</span>

<span class="sd">        Returns an opaque handle that may be passed to `remove_timeout`</span>
<span class="sd">        to cancel.  Note that unlike the `asyncio` method of the same</span>
<span class="sd">        name, the returned object does not have a ``cancel()`` method.</span>

<span class="sd">        See `add_timeout` for comments on thread-safety and subclassing.</span>

<span class="sd">        .. versionadded:: 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_timeout</span><span class="p">(</span><span class="n">when</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="IOLoop.remove_timeout"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.remove_timeout">[docs]</a>    <span class="k">def</span> <span class="nf">remove_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Cancels a pending timeout.</span>

<span class="sd">        The argument is a handle as returned by `add_timeout`.  It is</span>
<span class="sd">        safe to call `remove_timeout` even if the callback has already</span>
<span class="sd">        been run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="IOLoop.add_callback"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.add_callback">[docs]</a>    <span class="k">def</span> <span class="nf">add_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calls the given callback on the next I/O loop iteration.</span>

<span class="sd">        It is safe to call this method from any thread at any time,</span>
<span class="sd">        except from a signal handler.  Note that this is the **only**</span>
<span class="sd">        method in `IOLoop` that makes this thread-safety guarantee; all</span>
<span class="sd">        other interaction with the `IOLoop` must be done from that</span>
<span class="sd">        `IOLoop`&#39;s thread.  `add_callback()` may be used to transfer</span>
<span class="sd">        control from other threads to the `IOLoop`&#39;s thread.</span>

<span class="sd">        To add a callback from a signal handler, see</span>
<span class="sd">        `add_callback_from_signal`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="IOLoop.add_callback_from_signal"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.add_callback_from_signal">[docs]</a>    <span class="k">def</span> <span class="nf">add_callback_from_signal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calls the given callback on the next I/O loop iteration.</span>

<span class="sd">        Safe for use from a Python signal handler; should not be used</span>
<span class="sd">        otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="IOLoop.spawn_callback"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.spawn_callback">[docs]</a>    <span class="k">def</span> <span class="nf">spawn_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calls the given callback on the next IOLoop iteration.</span>

<span class="sd">        As of Tornado 6.0, this method is equivalent to `add_callback`.</span>

<span class="sd">        .. versionadded:: 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="IOLoop.add_future"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.add_future">[docs]</a>    <span class="k">def</span> <span class="nf">add_future</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">future</span><span class="p">:</span> <span class="s2">&quot;Union[Future[_T], concurrent.futures.Future[_T]]&quot;</span><span class="p">,</span>
        <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;Future[_T]&quot;</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Schedules a callback on the ``IOLoop`` when the given</span>
<span class="sd">        `.Future` is finished.</span>

<span class="sd">        The callback is invoked with one argument, the</span>
<span class="sd">        `.Future`.</span>

<span class="sd">        This method only accepts `.Future` objects and not other</span>
<span class="sd">        awaitables (unlike most of Tornado where the two are</span>
<span class="sd">        interchangeable).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">future</span><span class="p">,</span> <span class="n">Future</span><span class="p">):</span>
            <span class="c1"># Note that we specifically do not want the inline behavior of</span>
            <span class="c1"># tornado.concurrent.future_add_done_callback. We always want</span>
            <span class="c1"># this callback scheduled on the next IOLoop iteration (which</span>
            <span class="c1"># asyncio.Future always does).</span>
            <span class="c1">#</span>
            <span class="c1"># Wrap the callback in self._run_callback so we control</span>
            <span class="c1"># the error logging (i.e. it goes to tornado.log.app_log</span>
            <span class="c1"># instead of asyncio&#39;s log).</span>
            <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_callback</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="n">future</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">is_future</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
            <span class="c1"># For concurrent futures, we use self.add_callback, so</span>
            <span class="c1"># it&#39;s fine if future_add_done_callback inlines that call.</span>
            <span class="n">future_add_done_callback</span><span class="p">(</span>
                <span class="n">future</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="n">future</span><span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="IOLoop.run_in_executor"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.run_in_executor">[docs]</a>    <span class="k">def</span> <span class="nf">run_in_executor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">executor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">Executor</span><span class="p">],</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">_T</span><span class="p">],</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="p">[</span><span class="n">_T</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Runs a function in a ``concurrent.futures.Executor``. If</span>
<span class="sd">        ``executor`` is ``None``, the IO loop&#39;s default executor will be used.</span>

<span class="sd">        Use `functools.partial` to pass keyword arguments to ``func``.</span>

<span class="sd">        .. versionadded:: 5.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">executor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_executor&quot;</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">tornado.process</span> <span class="k">import</span> <span class="n">cpu_count</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span> <span class="o">=</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span>
                    <span class="n">max_workers</span><span class="o">=</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">()</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
                <span class="p">)</span>  <span class="c1"># type: concurrent.futures.Executor</span>
            <span class="n">executor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span>
        <span class="n">c_future</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="c1"># Concurrent Futures are not usable with await. Wrap this in a</span>
        <span class="c1"># Tornado Future instead, using self.add_future for thread-safety.</span>
        <span class="n">t_future</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>  <span class="c1"># type: Future[_T]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_future</span><span class="p">(</span><span class="n">c_future</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">chain_future</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t_future</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">t_future</span></div>

<div class="viewcode-block" id="IOLoop.set_default_executor"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.IOLoop.set_default_executor">[docs]</a>    <span class="k">def</span> <span class="nf">set_default_executor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">executor</span><span class="p">:</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">Executor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sets the default executor to use with :meth:`run_in_executor`.</span>

<span class="sd">        .. versionadded:: 5.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span> <span class="o">=</span> <span class="n">executor</span></div>

    <span class="k">def</span> <span class="nf">_run_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Runs a callback with error handling.</span>

<span class="sd">        .. versionchanged:: 6.0</span>

<span class="sd">           CancelledErrors are no longer logged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">callback</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">tornado</span> <span class="k">import</span> <span class="n">gen</span>

                <span class="c1"># Functions that return Futures typically swallow all</span>
                <span class="c1"># exceptions and store them in the Future.  If a Future</span>
                <span class="c1"># makes it out to the IOLoop, ensure its exception (if any)</span>
                <span class="c1"># gets logged too.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">convert_yielded</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">gen</span><span class="o">.</span><span class="n">BadYieldError</span><span class="p">:</span>
                    <span class="c1"># It&#39;s not unusual for add_callback to be used with</span>
                    <span class="c1"># methods returning a non-None and non-yieldable</span>
                    <span class="c1"># result, which should just be ignored.</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_future</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discard_future_result</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">app_log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Exception in callback </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_discard_future_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">:</span> <span class="n">Future</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Avoid unhandled-exception warnings from spawned coroutines.&quot;&quot;&quot;</span>
        <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">split_fd</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">_Selectable</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">_Selectable</span><span class="p">]]:</span>
        <span class="c1"># &quot;&quot;&quot;Returns an (fd, obj) pair from an ``fd`` parameter.</span>

        <span class="c1"># We accept both raw file descriptors and file-like objects as</span>
        <span class="c1"># input to `add_handler` and related methods.  When a file-like</span>
        <span class="c1"># object is passed, we must retain the object itself so we can</span>
        <span class="c1"># close it correctly when the `IOLoop` shuts down, but the</span>
        <span class="c1"># poller interfaces favor file descriptors (they will accept</span>
        <span class="c1"># file-like objects and call ``fileno()`` for you, but they</span>
        <span class="c1"># always return the descriptor itself).</span>

        <span class="c1"># This method is provided for use by `IOLoop` subclasses and should</span>
        <span class="c1"># not generally be used by application code.</span>

        <span class="c1"># .. versionadded:: 4.0</span>
        <span class="c1"># &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd</span>
        <span class="k">return</span> <span class="n">fd</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">fd</span>

    <span class="k">def</span> <span class="nf">close_fd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">_Selectable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># &quot;&quot;&quot;Utility method to close an ``fd``.</span>

        <span class="c1"># If ``fd`` is a file-like object, we close it directly; otherwise</span>
        <span class="c1"># we use `os.close`.</span>

        <span class="c1"># This method is provided for use by `IOLoop` subclasses (in</span>
        <span class="c1"># implementations of ``IOLoop.close(all_fds=True)`` and should</span>
        <span class="c1"># not generally be used by application code.</span>

        <span class="c1"># .. versionadded:: 4.0</span>
        <span class="c1"># &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fd</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">pass</span></div>


<span class="k">class</span> <span class="nc">_Timeout</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An IOLoop timeout, a UNIX timestamp and a callback&quot;&quot;&quot;</span>

    <span class="c1"># Reduce memory overhead when there are lots of pending callbacks</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;deadline&quot;</span><span class="p">,</span> <span class="s2">&quot;callback&quot;</span><span class="p">,</span> <span class="s2">&quot;tdeadline&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">deadline</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="kc">None</span><span class="p">],</span> <span class="n">io_loop</span><span class="p">:</span> <span class="n">IOLoop</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">deadline</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported deadline </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">deadline</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deadline</span> <span class="o">=</span> <span class="n">deadline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tdeadline</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">deadline</span><span class="p">,</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">io_loop</span><span class="o">.</span><span class="n">_timeout_counter</span><span class="p">),</span>
        <span class="p">)</span>  <span class="c1"># type: Tuple[float, int]</span>

    <span class="c1"># Comparison methods to sort by deadline, with object id as a tiebreaker</span>
    <span class="c1"># to guarantee a consistent ordering.  The heapq module uses __le__</span>
    <span class="c1"># in python2.5, and __lt__ in 2.6+ (sort() and most other comparisons</span>
    <span class="c1"># use __lt__).</span>
    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;_Timeout&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tdeadline</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">tdeadline</span>

    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;_Timeout&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tdeadline</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">tdeadline</span>


<div class="viewcode-block" id="PeriodicCallback"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.PeriodicCallback">[docs]</a><span class="k">class</span> <span class="nc">PeriodicCallback</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Schedules the given callback to be called periodically.</span>

<span class="sd">    The callback is called every ``callback_time`` milliseconds.</span>
<span class="sd">    Note that the timeout is given in milliseconds, while most other</span>
<span class="sd">    time-related functions in Tornado use seconds.</span>

<span class="sd">    If ``jitter`` is specified, each callback time will be randomly selected</span>
<span class="sd">    within a window of ``jitter * callback_time`` milliseconds.</span>
<span class="sd">    Jitter can be used to reduce alignment of events with similar periods.</span>
<span class="sd">    A jitter of 0.1 means allowing a 10% variation in callback time.</span>
<span class="sd">    The window is centered on ``callback_time`` so the total number of calls</span>
<span class="sd">    within a given interval should not be significantly affected by adding</span>
<span class="sd">    jitter.</span>

<span class="sd">    If the callback runs for longer than ``callback_time`` milliseconds,</span>
<span class="sd">    subsequent invocations will be skipped to get back on schedule.</span>

<span class="sd">    `start` must be called after the `PeriodicCallback` is created.</span>

<span class="sd">    .. versionchanged:: 5.0</span>
<span class="sd">       The ``io_loop`` argument (deprecated since version 4.1) has been removed.</span>

<span class="sd">    .. versionchanged:: 5.1</span>
<span class="sd">       The ``jitter`` argument is added.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="kc">None</span><span class="p">],</span> <span class="n">callback_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">jitter</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="k">if</span> <span class="n">callback_time</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Periodic callback must have a positive callback_time&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback_time</span> <span class="o">=</span> <span class="n">callback_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jitter</span> <span class="o">=</span> <span class="n">jitter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: object</span>

<div class="viewcode-block" id="PeriodicCallback.start"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.PeriodicCallback.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Starts the timer.&quot;&quot;&quot;</span>
        <span class="c1"># Looking up the IOLoop here allows to first instantiate the</span>
        <span class="c1"># PeriodicCallback in another thread, then start it using</span>
        <span class="c1"># IOLoop.add_callback().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span> <span class="o">=</span> <span class="n">IOLoop</span><span class="o">.</span><span class="n">current</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_schedule_next</span><span class="p">()</span></div>

<div class="viewcode-block" id="PeriodicCallback.stop"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.PeriodicCallback.stop">[docs]</a>    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Stops the timer.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">remove_timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="PeriodicCallback.is_running"><a class="viewcode-back" href="../../ioloop.html#tornado.ioloop.PeriodicCallback.is_running">[docs]</a>    <span class="k">def</span> <span class="nf">is_running</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns ``True`` if this `.PeriodicCallback` has been started.</span>

<span class="sd">        .. versionadded:: 4.1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_running</span></div>

    <span class="k">def</span> <span class="nf">_run</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_running</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">app_log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Exception in callback </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_schedule_next</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_schedule_next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_running</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_timeout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">callback_time_sec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_time</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jitter</span><span class="p">:</span>
            <span class="c1"># apply jitter fraction</span>
            <span class="n">callback_time_sec</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jitter</span> <span class="o">*</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_timeout</span> <span class="o">&lt;=</span> <span class="n">current_time</span><span class="p">:</span>
            <span class="c1"># The period should be measured from the start of one call</span>
            <span class="c1"># to the start of the next. If one call takes too long,</span>
            <span class="c1"># skip cycles to get back to a multiple of the original</span>
            <span class="c1"># schedule.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_timeout</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">current_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_timeout</span><span class="p">)</span> <span class="o">/</span> <span class="n">callback_time_sec</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">callback_time_sec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If the clock moved backwards, ensure we advance the next</span>
            <span class="c1"># timeout instead of recomputing the same value again.</span>
            <span class="c1"># This may result in long gaps between callbacks if the</span>
            <span class="c1"># clock jumps backwards by a lot, but the far more common</span>
            <span class="c1"># scenario is a small NTP adjustment that should just be</span>
            <span class="c1"># ignored.</span>
            <span class="c1">#</span>
            <span class="c1"># Note that on some systems if time.time() runs slower</span>
            <span class="c1"># than time.monotonic() (most common on windows), we</span>
            <span class="c1"># effectively experience a small backwards time jump on</span>
            <span class="c1"># every iteration because PeriodicCallback uses</span>
            <span class="c1"># time.time() while asyncio schedules callbacks using</span>
            <span class="c1"># time.monotonic().</span>
            <span class="c1"># https://github.com/tornadoweb/tornado/issues/2333</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_timeout</span> <span class="o">+=</span> <span class="n">callback_time_sec</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The Tornado Authors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>